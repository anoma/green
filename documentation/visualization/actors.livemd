<!-- livebook:{"persist_outputs":true} -->

# The Actors

## Index

1. [Contributing](./../CONTRIBUTING.livemd)
   1. [Git](./../contributing/git.livemd)
   2. [Hoon](./../contributing/hoon.livemd)
   3. [Iex](./../contributing/iex.livemd)
   4. [Observer](./../contributing/observer.livemd)
   5. [Testing](./../contributing/testing.livemd)
      1. [Running Tests](./../contributing/testing/running-tests.livemd)
      2. [Writing Tests](./../contributing/testing/writing-tests.livemd)
   6. [Understanding](./../contributing/understanding.livemd)
2. [Hoon](./../hoon.livemd)
   1. [Calling](./../hoon/calling.livemd)
   2. [Dumping](./../hoon/dumping.livemd)
   3. [Setting Up](./../hoon/setting-up.livemd)
3. [Index](./../index.livemd)
4. [Index_docs](./../index_docs.livemd)
5. [Visualization](./../visualization.livemd)
   1. [Actors](./../visualization/actors.livemd)
6. [Vm_interface](./../vm_interface.livemd)

## An overview of Anoma

A good overview of Actors can be seen by looking at the supervision tree of Anoma itself.

```elixir
{_, [pid1, pid2]} = Process.info(Process.whereis(:anoma), :links)
Kino.Process.render_sup_tree(pid2, direction: :left_right)
```

<!-- livebook:{"output":true} -->

```mermaid
graph LR;
0(supervisor 8J3EMO2/tIm1X1FGTGXmhEYXhCaLQGputAhv592OMi8=):::root ---> 1(Anoma.Node.Router 8J3EMO2/tIm1X1FGTGXmhEYXhCaLQGputAhv592OMi8=):::worker
0(supervisor 8J3EMO2/tIm1X1FGTGXmhEYXhCaLQGputAhv592OMi8=):::root ---> 2(Anoma.Node.Clock X2CsXLEbIdW7HEOG+OdELQSCtIcnZg7M7EnlHO93rE4=):::worker
0(supervisor 8J3EMO2/tIm1X1FGTGXmhEYXhCaLQGputAhv592OMi8=):::root ---> 3(Anoma.Node.Logger Tu0F2fmh+OUQlke8gPzWimUWd3SixO4Dvp7onk90IeI=):::worker
0(supervisor 8J3EMO2/tIm1X1FGTGXmhEYXhCaLQGputAhv592OMi8=):::root ---> 4(Anoma.Node.Storage.Ordering RsKdmG8JUie7hwOl0/doCBucVbxu/i+ijBbRwjiiphg=):::worker
0(supervisor 8J3EMO2/tIm1X1FGTGXmhEYXhCaLQGputAhv592OMi8=):::root ---> 5(Anoma.Node.Executor KDbunpxvR6yM9QkT+b93Eq5URdopVCOpQ3Upwtx6Avk=):::worker
0(supervisor 8J3EMO2/tIm1X1FGTGXmhEYXhCaLQGputAhv592OMi8=):::root ---> 6(Anoma.Node.Mempool AEXQkaiFMiDQXnBqf/M3i9RNy40fKyuAQHvB1+BPt3k=):::worker
0(supervisor 8J3EMO2/tIm1X1FGTGXmhEYXhCaLQGputAhv592OMi8=):::root ---> 7(Anoma.Node.Pinger PQqwlummewe0KPtWfKdWVlSgTVObtOcAyhDF7VBiCNA=):::worker
classDef root fill:#c4b5fd, stroke:#374151, stroke-width:4px;
classDef supervisor fill:#c4b5fd, stroke:#374151, stroke-width:1px;
classDef worker fill:#93c5fd, stroke:#374151, stroke-width:1px;
classDef notstarted color:#777, fill:#d9d9d9, stroke:#777, stroke-width:1px;


```

## Mempool

A good view of visualizing Anoma can be seen through running the
mempool, as it orchastrates the other actors in Anoma to act

<!-- livebook:{"break_markdown":true} -->

First we will create a transaction and see how that changes the base supervision tree before executing

```elixir
alias Anoma.Storage
alias Anoma.Node.Storage.Ordering
alias Anoma.Node.Mempool
alias Anoma.Node.Router
import TestHelper.Nock

storage = %Anoma.Storage{
  qualified: Anoma.Qualified,
  order: Anoma.Order
}

name = :anoma
node = Anoma.Node.state(name)
key = 555
zero = zero_counter(key)
pid_zero = Mempool.tx(node.mempool, {:kv, zero}).pid
```

<!-- livebook:{"output":true} -->

```
#PID<0.583.0>
```

The previous evaluations PID can be seen in the diagram below!

```elixir
{_, [pid1, pid2]} = Process.info(Process.whereis(:anoma), :links)
Kino.Process.render_sup_tree(pid2, direction: :left_right)
```

<!-- livebook:{"output":true} -->

```mermaid
graph LR;
0(supervisor 8J3EMO2/tIm1X1FGTGXmhEYXhCaLQGputAhv592OMi8=):::root ---> 1(Anoma.Node.Router 8J3EMO2/tIm1X1FGTGXmhEYXhCaLQGputAhv592OMi8=):::worker
0(supervisor 8J3EMO2/tIm1X1FGTGXmhEYXhCaLQGputAhv592OMi8=):::root ---> 2(Anoma.Node.Clock X2CsXLEbIdW7HEOG+OdELQSCtIcnZg7M7EnlHO93rE4=):::worker
0(supervisor 8J3EMO2/tIm1X1FGTGXmhEYXhCaLQGputAhv592OMi8=):::root ---> 3(Anoma.Node.Logger Tu0F2fmh+OUQlke8gPzWimUWd3SixO4Dvp7onk90IeI=):::worker
0(supervisor 8J3EMO2/tIm1X1FGTGXmhEYXhCaLQGputAhv592OMi8=):::root ---> 4(Anoma.Node.Storage.Ordering RsKdmG8JUie7hwOl0/doCBucVbxu/i+ijBbRwjiiphg=):::worker
0(supervisor 8J3EMO2/tIm1X1FGTGXmhEYXhCaLQGputAhv592OMi8=):::root ---> 5(Anoma.Node.Executor KDbunpxvR6yM9QkT+b93Eq5URdopVCOpQ3Upwtx6Avk=):::worker
0(supervisor 8J3EMO2/tIm1X1FGTGXmhEYXhCaLQGputAhv592OMi8=):::root ---> 6(Anoma.Node.Mempool AEXQkaiFMiDQXnBqf/M3i9RNy40fKyuAQHvB1+BPt3k=):::worker
0(supervisor 8J3EMO2/tIm1X1FGTGXmhEYXhCaLQGputAhv592OMi8=):::root ---> 7(Anoma.Node.Pinger PQqwlummewe0KPtWfKdWVlSgTVObtOcAyhDF7VBiCNA=):::worker
classDef root fill:#c4b5fd, stroke:#374151, stroke-width:4px;
classDef supervisor fill:#c4b5fd, stroke:#374151, stroke-width:1px;
classDef worker fill:#93c5fd, stroke:#374151, stroke-width:1px;
classDef notstarted color:#777, fill:#d9d9d9, stroke:#777, stroke-width:1px;


```

Now let us see what happens between the actors when we run the mempool

```elixir
Kino.Process.render_seq_trace(
  [Process.whereis(node.mempool.server)],
  fn ->
    Mempool.execute(node.mempool)
  end,
  message_label: &Anoma.Node.Utility.message_label/1
)
```

<!-- livebook:{"output":true} -->

```mermaid
sequenceDiagram
participant 3 AS code_server;
participant 7 AS mnesia_locker;
participant 6 AS mnesia_tm;
participant 8 AS Anoma.Node.Router 8J3EMO2/tIm1X1FGTGXmhEYXhCaLQGputAhv592OMi8=;
participant 2 AS Anoma.Node.Logger Tu0F2fmh+OUQlke8gPzWimUWd3SixO4Dvp7onk90IeI=;
participant 4 AS Anoma.Node.Storage.Ordering RsKdmG8JUie7hwOl0/doCBucVbxu/i+ijBbRwjiiphg=;
participant 1 AS Anoma.Node.Mempool AEXQkaiFMiDQXnBqf/M3i9RNy40fKyuAQHvB1+BPt3k=;
participant 0 AS self();
participant 5 AS #35;PID<0.583.0>;
0->>1: CALL: execute
1->>2: ADD LEVEL: info
1->>3: INFO: code_call
3->>1: INFO: code_server
1->>3: INFO: code_call
3->>1: INFO: code_server
1->>3: INFO: code_call
3->>1: INFO: code_server
1->>3: INFO: code_call
3->>1: INFO: code_server
1->>4: CALL: next_order
4->>1: INFO: tuple
1->>3: INFO: code_call
3->>1: INFO: code_server
1->>3: INFO: code_call
3->>1: INFO: code_server
1->>2: ADD LEVEL: info
1->>4: CALL: new_order
4->>1: INFO: tuple
1->>2: ADD LEVEL: info
1->>5: INFO: write_ready
1->>2: ADD LEVEL: info
1->>6: INFO: tuple
6->>1: INFO: mnesia_tm
1->>7: INFO: tuple
7->>1: INFO: mnesia_locker
1->>7: INFO: release_tid
1->>6: INFO: delete_transaction
1->>2: ADD LEVEL: info
1->>2: ADD LEVEL: info
1->>8: CAST: cast
1->>0: INFO: tuple

```

<!-- livebook:{"output":true} -->

```
{:ok, 1}
```

As we can see, we get a fairly solid overview of what actors sent what messages

<!-- livebook:{"break_markdown":true} -->

We can also see what processes startup when we start an execution

```elixir
Kino.Process.render_seq_trace(
  [Process.whereis(node.mempool.server)],
  fn -> Mempool.tx(node.mempool, {:kv, increment_counter_val(555)}).pid() end,
  message_label: &Anoma.Node.Utility.message_label/1
)
```

<!-- livebook:{"output":true} -->

```mermaid
sequenceDiagram
participant 4 AS Anoma.Node.Router 8J3EMO2/tIm1X1FGTGXmhEYXhCaLQGputAhv592OMi8=;
participant 2 AS Anoma.Node.Logger Tu0F2fmh+OUQlke8gPzWimUWd3SixO4Dvp7onk90IeI=;
participant 3 AS Anoma.Node.Executor KDbunpxvR6yM9QkT+b93Eq5URdopVCOpQ3Upwtx6Avk=;
participant 1 AS Anoma.Node.Mempool AEXQkaiFMiDQXnBqf/M3i9RNy40fKyuAQHvB1+BPt3k=;
participant 0 AS self();
0->>1: CALL: tx
1->>2: ADD LEVEL: info
1->>3: CALL: transaction
3->>1: INFO: tuple
1->>4: CAST: cast
1->>2: ADD LEVEL: info
1->>0: INFO: tuple

```

<!-- livebook:{"output":true} -->

```
#PID<0.586.0>
```

```elixir
Kino.Process.render_seq_trace(
  :all,
  fn -> Anoma.Node.Logger.add(node.logger, :info, "help") end,
  message_label: &Anoma.Node.Utility.message_label/1
)
```

<!-- livebook:{"output":true} -->

```mermaid
sequenceDiagram
participant 1 AS Anoma.Node.Logger Tu0F2fmh+OUQlke8gPzWimUWd3SixO4Dvp7onk90IeI=;
participant 0 AS self();
0->>1: ADD LEVEL: info

```

<!-- livebook:{"output":true} -->

```
:ok
```
